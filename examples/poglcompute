#!perl

use strict;
use warnings;
use OpenGL::Modern qw(
  glewCreateContext glewInit glewDestroyContext glpCheckErrors glGetString
  glGenTextures_p glBindTexture glDeleteTextures_p
  glTexImage2D_c glTexParameteri
  glGetTexLevelParameteriv_p glGetIntegerv_p
  glPixelStorei glGetTexImage_c
  glActiveTexture
  glCreateShader glDeleteShader glShaderSource_p glCompileShader
  glAttachShader glDetachShader
  glGetShaderiv_p glGetShaderInfoLog_p
  glCreateProgram glDeleteProgram glLinkProgram glUseProgram
  glGetProgramiv_p glGetProgramInfoLog_p
  glGenFramebuffers_p glBindFramebuffer glDeleteFramebuffers_p
  glFramebufferTexture glCheckFramebufferStatus
  glGenBuffers_p glDeleteBuffers_p glBindBuffer glBufferData_c
  glGenVertexArrays_p glDeleteVertexArrays_p glBindVertexArray
  glViewport glVertexAttribPointer_c
  glEnableVertexAttribArray glDisableVertexAttribArray
  glDrawArrays
  GL_FRAMEBUFFER GL_COLOR_ATTACHMENT0 GL_FRAMEBUFFER_COMPLETE
  GL_PACK_ALIGNMENT
  GL_TEXTURE_2D GL_R32F GL_RED GL_FLOAT GL_COLOR_BUFFER_BIT
  GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER
  GL_TEXTURE1
  GL_TEXTURE_WIDTH GL_TEXTURE_HEIGHT GL_MAX_TEXTURE_SIZE GL_MAX_VIEWPORT_DIMS
  GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_NEAREST GL_CLAMP_TO_EDGE
  GL_VERSION GLEW_OK
  GL_COMPILE_STATUS GL_LINK_STATUS GL_FALSE
  GL_VERTEX_SHADER GL_FRAGMENT_SHADER
  GL_ARRAY_BUFFER GL_STATIC_DRAW GL_TRIANGLE_STRIP
);
use PDL;

sub with_time (&$) {
  require Time::HiRes;
  my @t = Time::HiRes::gettimeofday();
  &{$_[0]}();
  printf "$_[1]: %g ms\n", Time::HiRes::tv_interval(\@t) * 1000;
}

print "Perl $^V OpenGL::Modern $OpenGL::Modern::VERSION PDL $PDL::VERSION\n";

my ($xdim, $ydim) = (3048, 3048);

# 4.1 core so MacOS allows >2.1
glewCreateContext(4, 1, 1, 2) == GLEW_OK or die "glewCreateContext failed";
glewInit() == GLEW_OK or die "glewInit failed";
print "OpenGL ", glGetString(GL_VERSION), "\n";
my $max_tex_dim = glGetIntegerv_p(GL_MAX_TEXTURE_SIZE);
print "Max texture dim = $max_tex_dim\n";
my $max_vp_dim = glGetIntegerv_p(GL_MAX_VIEWPORT_DIMS);
print "Max viewport dim = $max_vp_dim\n";

my $vertex_shader = <<'EOF';
#version 330
layout(location = 0) in vec2 pos;
void main() {
  gl_Position = vec4(pos, 0.0, 1.0);
}
EOF

my $fragment_shader = <<'EOF';
#version 330
precision highp float;
out vec4 outputColor;

void main() {
  outputColor = vec4(-0.5, 0, 0, 1);
}
EOF

my $pos_data = float('1.0 -1.0; 1.0 1.0; -1.0 -1.0; -1.0 1.0');
my $program = compile_program($vertex_shader, $fragment_shader);
my $attrib_buffer = glGenBuffers_p(1);
glBindBuffer(GL_ARRAY_BUFFER, $attrib_buffer);
glBufferData_c(GL_ARRAY_BUFFER, $pos_data->nbytes, $pos_data->make_physical->address_data, GL_STATIC_DRAW);
glBindBuffer(GL_ARRAY_BUFFER, 0);
my $vao = glGenVertexArrays_p(1);
glBindVertexArray($vao);

my ($type, $internalformat, $format) = (GL_FLOAT, GL_R32F, GL_RED);

my ($destTextureID) = glGenTextures_p(1);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, $destTextureID);
my ($dim0, $dim1) = ($xdim, $ydim);
glTexImage2D_c(GL_TEXTURE_2D, 0, $internalformat, $dim0, $dim1,
  0, $format, $type, 0);
glBindTexture(GL_TEXTURE_2D, 0);

my ($fbo_id) = glGenFramebuffers_p(1);
glBindFramebuffer(GL_FRAMEBUFFER, $fbo_id);
glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, $destTextureID, 0);
my $fbstat = glCheckFramebufferStatus(GL_FRAMEBUFFER);
die "FBO Status error: " . glpErrorString(glGetError()) if !$fbstat;
die sprintf "FBO Status: %04X", $fbstat if $fbstat != GL_FRAMEBUFFER_COMPLETE;

with_time {
glViewport(0,0,$xdim,$ydim);
glBindBuffer(GL_ARRAY_BUFFER, $attrib_buffer);
glVertexAttribPointer_c(0, 2, GL_FLOAT, GL_FALSE, 0, 0);
glEnableVertexAttribArray(0);
glBindTexture(GL_TEXTURE_2D, $destTextureID);
tex_parameters();
glUseProgram($program);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
glUseProgram(0);
glBindTexture(GL_TEXTURE_2D, 0);
glDisableVertexAttribArray(0);
glBindBuffer(GL_ARRAY_BUFFER, 0);
} 'render';

my $p2 = zeroes(float, $xdim, $ydim);
my $skip = $p2->dim(1)-1;
my $slicearg = '-10:-1,::'.$skip;
print "Before: ", $p2->slice($slicearg), "\n";
with_time {
glBindTexture(GL_TEXTURE_2D, $destTextureID);
my ($w, $h) = map glGetTexLevelParameteriv_p(GL_TEXTURE_2D, 0, $_), GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT;
print "Texture $w x $h\n";
glPixelStorei(GL_PACK_ALIGNMENT, 1);
glGetTexImage_c(GL_TEXTURE_2D, 0, $format, $type, $p2->address_data);
glBindTexture(GL_TEXTURE_2D, 0);
} 'copy dest to CPU';
print "After: ", $p2->slice($slicearg);

glpCheckErrors();
END {
glBindTexture(GL_TEXTURE_2D, 0);
glDeleteTextures_p($_) for grep $_, $destTextureID;
glBindFramebuffer(GL_FRAMEBUFFER, 0);
glDeleteFramebuffers_p($_) for grep $_, $fbo_id;
glBindVertexArray(0);
glDeleteVertexArrays_p($_) for grep $_, $vao;
glUseProgram(0);
glDeleteProgram($_) for grep $_, $program;
glBindBuffer(GL_ARRAY_BUFFER, 0);
glDeleteBuffers_p($_) for grep $_, $attrib_buffer;
glewDestroyContext();
}

sub tex_parameters {
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
}

sub compile_shader {
  my ($type, $src) = @_;
  my $shader = glCreateShader($type);
  glShaderSource_p($shader, $src);
  glCompileShader($shader);
  my $status = glGetShaderiv_p($shader, GL_COMPILE_STATUS);
  if ($status == GL_FALSE) {
    my $str = sprintf("%s shader compilation failed!\n",
        $type == GL_VERTEX_SHADER ? "Vertex" : "Fragment");
    $str .= glGetShaderInfoLog_p($shader);
    glDeleteShader($shader);
    die $str;
  }
  $shader;
}

sub compile_program {
  my ($vsrc, $fsrc) = @_;
  my $vShader = compile_shader(GL_VERTEX_SHADER, $vsrc);
  my $fShader = eval { compile_shader(GL_FRAGMENT_SHADER, $fsrc) };
  if (my $err = $@) {
    glDeleteShader($vShader);
    die $err;
  }
  my $program = glCreateProgram();
  glAttachShader($program, $vShader);
  glAttachShader($program, $fShader);
  glLinkProgram($program);
  my $status = glGetProgramiv_p($program, GL_LINK_STATUS);
  glDetachShader($program, $vShader);
  glDetachShader($program, $fShader);
  glDeleteShader($vShader);
  glDeleteShader($fShader);
  if ($status == GL_FALSE) {
    my $str = "Program linker failed.\n";
    $str .= glGetProgramInfoLog_p($program);
    glDeleteProgram($program);
    die $str;
  }
  $program;
}
